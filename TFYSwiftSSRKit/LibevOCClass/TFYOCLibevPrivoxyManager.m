//
//  TFYOCLibevPrivoxyManager.m
//  TFYSwiftSSRKit
//
//  Created for TFYSwiftSSRKit on 2024
//  Copyright © 2024 TFYSwiftSSRKit. All rights reserved.
//

#import "TFYOCLibevPrivoxyManager.h"
#import <pthread.h>

// 导入privoxy头文件
#include "../shadowsocks-libev/privoxy/include/privoxy.h"

// 错误域
NSString * const TFYOCLibevPrivoxyErrorDomain = @"com.tfyswiftssrkit.privoxy";

// 错误码
typedef NS_ENUM(NSInteger, TFYOCLibevPrivoxyErrorCode) {
    TFYOCLibevPrivoxyErrorCodeStartFailed = 1001,
    TFYOCLibevPrivoxyErrorCodeConfigFailed = 1002,
    TFYOCLibevPrivoxyErrorCodeRuleFailed = 1003
};

// 私有函数声明
static void privoxy_log_callback(const char *message);

// 全局变量
static TFYOCLibevPrivoxyManager *sharedInstance = nil;
static char *configFilePath = NULL;

@implementation TFYPrivoxyConfig

- (instancetype)init {
    self = [super init];
    if (self) {
        // 设置默认值
        _listenAddress = @"127.0.0.1";
        _listenPort = 8118;
        _connectionTimeout = 60;
        _socketTimeout = 30;
        _maxClientConnections = 50;
        _enableFiltering = YES;
        _enableCompression = YES;
        _enableRemoteToggle = NO;
    }
    return self;
}

+ (instancetype)configWithListenPort:(int)listenPort
                   forwardSOCKS5Host:(NSString *)forwardSOCKS5Host
                   forwardSOCKS5Port:(int)forwardSOCKS5Port {
    TFYPrivoxyConfig *config = [[TFYPrivoxyConfig alloc] init];
    config.listenPort = listenPort;
    config.forwardSOCKS5Host = forwardSOCKS5Host;
    config.forwardSOCKS5Port = forwardSOCKS5Port;
    return config;
}

@end

@implementation TFYPrivoxyFilterRule

- (instancetype)init {
    self = [super init];
    if (self) {
        _action = TFYPrivoxyFilterActionBlock;
    }
    return self;
}

+ (instancetype)ruleWithPattern:(NSString *)pattern
                         action:(TFYPrivoxyFilterAction)action
                    description:(NSString *)description {
    TFYPrivoxyFilterRule *rule = [[TFYPrivoxyFilterRule alloc] init];
    rule.pattern = [pattern copy];
    rule.action = action;
    rule.ruleDescription = [description copy];
    return rule;
}

@end

@interface TFYOCLibevPrivoxyManager ()

@property (nonatomic, strong) NSMutableArray<TFYPrivoxyFilterRule *> *filterRules;
@property (nonatomic, strong) dispatch_queue_t managerQueue;
@property (nonatomic, assign, readwrite) BOOL isRunning;

@end

@implementation TFYOCLibevPrivoxyManager

#pragma mark - 生命周期方法

+ (instancetype)sharedManager {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[TFYOCLibevPrivoxyManager alloc] init];
    });
    return sharedInstance;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _filterRules = [NSMutableArray array];
        _managerQueue = dispatch_queue_create("com.tfyswiftssrkit.privoxy.manager", DISPATCH_QUEUE_SERIAL);
        _isRunning = NO;
        
        // 设置默认配置
        _config = [[TFYPrivoxyConfig alloc] init];
        
        // 初始化Privoxy
        privoxy_init();
    }
    return self;
}

- (void)dealloc {
    [self stopPrivoxy];
    
    if (configFilePath) {
        free(configFilePath);
        configFilePath = NULL;
    }
    
    // 清理Privoxy资源
    privoxy_cleanup();
}

#pragma mark - 私有方法

- (NSString *)temporaryConfigFilePath {
    NSString *tempDir = NSTemporaryDirectory();
    NSString *configFileName = [NSString stringWithFormat:@"privoxy_config_%@.conf", [[NSUUID UUID] UUIDString]];
    return [tempDir stringByAppendingPathComponent:configFileName];
}

- (NSString *)configFileContent {
    NSMutableString *content = [NSMutableString string];
    
    // 基本配置
    [content appendFormat:@"# Privoxy configuration generated by TFYSwiftSSRKit\n"];
    [content appendFormat:@"listen-address %@:%d\n", self.config.listenAddress, self.config.listenPort];
    
    // 转发配置
    if (self.config.forwardSOCKS5Host) {
        [content appendFormat:@"forward-socks5 / %@:%d .\n", 
                 self.config.forwardSOCKS5Host, self.config.forwardSOCKS5Port];
    }
    
    if (self.config.forwardHTTPHost) {
        [content appendFormat:@"forward / %@:%d\n", 
                 self.config.forwardHTTPHost, self.config.forwardHTTPPort];
    }
    
    // 超时设置
    [content appendFormat:@"connection-timeout %d\n", self.config.connectionTimeout];
    [content appendFormat:@"socket-timeout %d\n", self.config.socketTimeout];
    [content appendFormat:@"max-client-connections %d\n", self.config.maxClientConnections];
    
    // 功能开关
    [content appendFormat:@"toggle %d\n", self.config.enableFiltering ? 1 : 0];
    [content appendFormat:@"enable-compression %d\n", self.config.enableCompression ? 1 : 0];
    [content appendFormat:@"enable-remote-toggle %d\n", self.config.enableRemoteToggle ? 1 : 0];
    
    // 日志设置
    if (self.config.logFilePath) {
        [content appendFormat:@"logfile %@\n", self.config.logFilePath];
    } else {
        [content appendString:@"logfile logfile\n"];
    }
    
    // 过滤规则
    [content appendString:@"\n# Filter rules\n"];
    for (TFYPrivoxyFilterRule *rule in self.filterRules) {
        NSString *actionStr = @"block";
        switch (rule.action) {
            case TFYPrivoxyFilterActionAllow:
                actionStr = @"allow";
                break;
            case TFYPrivoxyFilterActionFilter:
                actionStr = @"filter";
                break;
            default:
                actionStr = @"block";
                break;
        }
        
        if (rule.ruleDescription) {
            [content appendFormat:@"# %@\n", rule.ruleDescription];
        }
        [content appendFormat:@"{%@} %@\n", actionStr, rule.pattern];
    }
    
    return content;
}

- (BOOL)writeConfigFile {
    if (!self.config) {
        return NO;
    }
    
    NSString *configPath = self.config.configFilePath;
    if (!configPath) {
        configPath = [self temporaryConfigFilePath];
        self.config.configFilePath = configPath;
    }
    
    NSString *content = [self configFileContent];
    NSError *error = nil;
    BOOL success = [content writeToFile:configPath
                             atomically:YES
                               encoding:NSUTF8StringEncoding
                                  error:&error];
    
    if (!success) {
        if (self.delegate && [self.delegate respondsToSelector:@selector(privoxyDidEncounterError:)]) {
            NSError *configError = [NSError errorWithDomain:TFYOCLibevPrivoxyErrorDomain
                                                       code:TFYOCLibevPrivoxyErrorCodeConfigFailed
                                                   userInfo:@{NSLocalizedDescriptionKey: @"Failed to write config file",
                                                              NSUnderlyingErrorKey: error}];
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.delegate privoxyDidEncounterError:configError];
            });
        }
    }
    
    return success;
}

#pragma mark - 公共方法

- (BOOL)startPrivoxy {
    __block BOOL success = NO;
    
    dispatch_sync(self.managerQueue, ^{
        if (self.isRunning) {
            success = YES;
            return;
        }
        
        // 写入配置文件
        if (![self writeConfigFile]) {
            return;
        }
        
        // 设置配置文件路径
        if (configFilePath) {
            free(configFilePath);
        }
        configFilePath = strdup([self.config.configFilePath UTF8String]);
        
        // 启动Privoxy
        int result = privoxy_start(self.config.listenPort, configFilePath);
        if (result != 0) {
            NSError *error = [NSError errorWithDomain:TFYOCLibevPrivoxyErrorDomain
                                                 code:TFYOCLibevPrivoxyErrorCodeStartFailed
                                             userInfo:@{NSLocalizedDescriptionKey: @"Failed to start Privoxy"}];
            
            if (self.delegate && [self.delegate respondsToSelector:@selector(privoxyDidEncounterError:)]) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self.delegate privoxyDidEncounterError:error];
                });
            }
            return;
        }
        
        // 设置过滤规则
        for (TFYPrivoxyFilterRule *rule in self.filterRules) {
            NSString *ruleString = [NSString stringWithFormat:@"{%@} %@", 
                                   rule.action == TFYPrivoxyFilterActionAllow ? @"allow" : 
                                   (rule.action == TFYPrivoxyFilterActionFilter ? @"filter" : @"block"), 
                                   rule.pattern];
            privoxy_add_filter([ruleString UTF8String]);
        }
        
        // 设置过滤和压缩选项
        privoxy_toggle_filtering(self.config.enableFiltering ? 1 : 0);
        privoxy_toggle_compression(self.config.enableCompression ? 1 : 0);
        
        self.isRunning = YES;
        success = YES;
        
        if (self.delegate && [self.delegate respondsToSelector:@selector(privoxyDidStart)]) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.delegate privoxyDidStart];
            });
        }
    });
    
    return success;
}

- (void)stopPrivoxy {
    dispatch_sync(self.managerQueue, ^{
        if (!self.isRunning) {
            return;
        }
        
        // 停止Privoxy
        privoxy_stop();
        
        self.isRunning = NO;
        
        if (self.delegate && [self.delegate respondsToSelector:@selector(privoxyDidStop)]) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.delegate privoxyDidStop];
            });
        }
    });
}

- (BOOL)restartPrivoxy {
    [self stopPrivoxy];
    return [self startPrivoxy];
}

- (BOOL)addFilterRule:(TFYPrivoxyFilterRule *)rule {
    if (!rule || !rule.pattern) {
        return NO;
    }
    
    __block BOOL success = NO;
    
    dispatch_sync(self.managerQueue, ^{
        // 检查是否已存在相同模式的规则
        NSUInteger existingIndex = NSNotFound;
        for (NSUInteger i = 0; i < self.filterRules.count; i++) {
            if ([self.filterRules[i].pattern isEqualToString:rule.pattern]) {
                existingIndex = i;
                break;
            }
        }
        
        if (existingIndex != NSNotFound) {
            // 更新现有规则
            self.filterRules[existingIndex] = rule;
        } else {
            // 添加新规则
            [self.filterRules addObject:rule];
        }
        
        // 如果privoxy正在运行，需要添加规则
        if (self.isRunning) {
            NSString *ruleString = [NSString stringWithFormat:@"{%@} %@", 
                                   rule.action == TFYPrivoxyFilterActionAllow ? @"allow" : 
                                   (rule.action == TFYPrivoxyFilterActionFilter ? @"filter" : @"block"), 
                                   rule.pattern];
            int result = privoxy_add_filter([ruleString UTF8String]);
            success = (result == 0);
        } else {
            success = [self writeConfigFile];
        }
    });
    
    return success;
}

- (BOOL)removeFilterRuleWithPattern:(NSString *)pattern {
    if (!pattern) {
        return NO;
    }
    
    __block BOOL success = NO;
    
    dispatch_sync(self.managerQueue, ^{
        // 查找匹配的规则
        NSUInteger indexToRemove = NSNotFound;
        for (NSUInteger i = 0; i < self.filterRules.count; i++) {
            if ([self.filterRules[i].pattern isEqualToString:pattern]) {
                indexToRemove = i;
                break;
            }
        }
        
        if (indexToRemove != NSNotFound) {
            // 移除规则
            [self.filterRules removeObjectAtIndex:indexToRemove];
            
            // 如果privoxy正在运行，需要移除规则
            if (self.isRunning) {
                int result = privoxy_remove_filter([pattern UTF8String]);
                success = (result == 0);
            } else {
                success = [self writeConfigFile];
            }
        }
    });
    
    return success;
}

- (NSArray<TFYPrivoxyFilterRule *> *)allFilterRules {
    __block NSArray<TFYPrivoxyFilterRule *> *rules = nil;
    
    dispatch_sync(self.managerQueue, ^{
        rules = [self.filterRules copy];
    });
    
    return rules;
}

- (BOOL)clearAllFilterRules {
    __block BOOL success = NO;
    
    dispatch_sync(self.managerQueue, ^{
        [self.filterRules removeAllObjects];
        
        // 如果privoxy正在运行，需要清除所有规则
        if (self.isRunning) {
            int result = privoxy_clear_filters();
            success = (result == 0);
        } else {
            success = [self writeConfigFile];
        }
    });
    
    return success;
}

- (BOOL)toggleFiltering:(BOOL)enabled {
    __block BOOL success = NO;
    
    dispatch_sync(self.managerQueue, ^{
        self.config.enableFiltering = enabled;
        
        // 如果privoxy正在运行，需要切换过滤状态
        if (self.isRunning) {
            int result = privoxy_toggle_filtering(enabled ? 1 : 0);
            success = (result == 0);
        } else {
            success = [self writeConfigFile];
        }
    });
    
    return success;
}

- (BOOL)toggleCompression:(BOOL)enabled {
    __block BOOL success = NO;
    
    dispatch_sync(self.managerQueue, ^{
        self.config.enableCompression = enabled;
        
        // 如果privoxy正在运行，需要切换压缩状态
        if (self.isRunning) {
            int result = privoxy_toggle_compression(enabled ? 1 : 0);
            success = (result == 0);
        } else {
            success = [self writeConfigFile];
        }
    });
    
    return success;
}

- (BOOL)generateConfigFile {
    return [self writeConfigFile];
}

- (BOOL)loadConfigFile:(NSString *)filePath {
    if (!filePath) {
        return NO;
    }
    
    NSError *error = nil;
    NSString *content = [NSString stringWithContentsOfFile:filePath
                                                  encoding:NSUTF8StringEncoding
                                                     error:&error];
    
    if (!content) {
        if (self.delegate && [self.delegate respondsToSelector:@selector(privoxyDidEncounterError:)]) {
            NSError *loadError = [NSError errorWithDomain:TFYOCLibevPrivoxyErrorDomain
                                                     code:TFYOCLibevPrivoxyErrorCodeConfigFailed
                                                 userInfo:@{NSLocalizedDescriptionKey: @"Failed to load config file",
                                                            NSUnderlyingErrorKey: error}];
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.delegate privoxyDidEncounterError:loadError];
            });
        }
        return NO;
    }
    
    // 创建新的配置对象
    TFYPrivoxyConfig *newConfig = [[TFYPrivoxyConfig alloc] init];
    newConfig.configFilePath = filePath;
    
    // 解析配置文件内容
    NSArray<NSString *> *lines = [content componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    NSMutableArray<TFYPrivoxyFilterRule *> *newRules = [NSMutableArray array];
    
    for (NSString *line in lines) {
        // 跳过空行和注释行
        NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmedLine.length == 0 || [trimmedLine hasPrefix:@"#"]) {
            continue;
        }
        
        // 解析监听地址和端口
        if ([trimmedLine hasPrefix:@"listen-address"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                NSString *addressPort = components[1];
                NSArray<NSString *> *addressComponents = [addressPort componentsSeparatedByString:@":"];
                if (addressComponents.count == 2) {
                    newConfig.listenAddress = addressComponents[0];
                    newConfig.listenPort = [addressComponents[1] intValue];
                }
            }
        }
        // 解析SOCKS5转发
        else if ([trimmedLine hasPrefix:@"forward-socks5"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 3) {
                NSString *addressPort = components[2];
                NSArray<NSString *> *addressComponents = [addressPort componentsSeparatedByString:@":"];
                if (addressComponents.count == 2) {
                    newConfig.forwardSOCKS5Host = addressComponents[0];
                    newConfig.forwardSOCKS5Port = [addressComponents[1] intValue];
                }
            }
        }
        // 解析HTTP转发
        else if ([trimmedLine hasPrefix:@"forward"] && ![trimmedLine hasPrefix:@"forward-socks"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 3) {
                NSString *addressPort = components[2];
                NSArray<NSString *> *addressComponents = [addressPort componentsSeparatedByString:@":"];
                if (addressComponents.count == 2) {
                    newConfig.forwardHTTPHost = addressComponents[0];
                    newConfig.forwardHTTPPort = [addressComponents[1] intValue];
                }
            }
        }
        // 解析连接超时
        else if ([trimmedLine hasPrefix:@"connection-timeout"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                newConfig.connectionTimeout = [components[1] intValue];
            }
        }
        // 解析Socket超时
        else if ([trimmedLine hasPrefix:@"socket-timeout"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                newConfig.socketTimeout = [components[1] intValue];
            }
        }
        // 解析最大客户端连接数
        else if ([trimmedLine hasPrefix:@"max-client-connections"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                newConfig.maxClientConnections = [components[1] intValue];
            }
        }
        // 解析过滤开关
        else if ([trimmedLine hasPrefix:@"toggle"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                newConfig.enableFiltering = [components[1] intValue] != 0;
            }
        }
        // 解析压缩开关
        else if ([trimmedLine hasPrefix:@"enable-compression"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                newConfig.enableCompression = [components[1] intValue] != 0;
            }
        }
        // 解析远程切换开关
        else if ([trimmedLine hasPrefix:@"enable-remote-toggle"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                newConfig.enableRemoteToggle = [components[1] intValue] != 0;
            }
        }
        // 解析日志文件路径
        else if ([trimmedLine hasPrefix:@"logfile"]) {
            NSArray<NSString *> *components = [trimmedLine componentsSeparatedByString:@" "];
            if (components.count >= 2) {
                NSString *logPath = components[1];
                if (![logPath isEqualToString:@"logfile"]) {
                    newConfig.logFilePath = logPath;
                }
            }
        }
        // 解析过滤规则
        else if ([trimmedLine hasPrefix:@"{"]) {
            NSString *description = nil;
            
            // 查找前一行是否为注释，作为规则描述
            NSInteger lineIndex = [lines indexOfObject:line];
            if (lineIndex > 0) {
                NSString *prevLine = [lines[lineIndex - 1] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                if ([prevLine hasPrefix:@"#"]) {
                    description = [prevLine substringFromIndex:1];
                    description = [description stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                }
            }
            
            // 解析动作和模式
            NSRange actionRange = [trimmedLine rangeOfString:@"}"];
            if (actionRange.location != NSNotFound) {
                NSString *actionStr = [trimmedLine substringWithRange:NSMakeRange(1, actionRange.location - 1)];
                NSString *pattern = [trimmedLine substringFromIndex:actionRange.location + 1];
                pattern = [pattern stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                
                TFYPrivoxyFilterAction action = TFYPrivoxyFilterActionBlock;
                if ([actionStr isEqualToString:@"allow"]) {
                    action = TFYPrivoxyFilterActionAllow;
                } else if ([actionStr isEqualToString:@"filter"]) {
                    action = TFYPrivoxyFilterActionFilter;
                }
                
                TFYPrivoxyFilterRule *rule = [TFYPrivoxyFilterRule ruleWithPattern:pattern
                                                                           action:action
                                                                      description:description];
                [newRules addObject:rule];
            }
        }
    }
    
    // 更新配置和规则
    self.config = newConfig;
    [self.filterRules removeAllObjects];
    [self.filterRules addObjectsFromArray:newRules];
    
    // 如果正在运行，需要重启
    if (self.isRunning) {
        return [self restartPrivoxy];
    }
    
    return YES;
}

@end

#pragma mark - 回调函数

// 添加 __unused 属性以消除未使用函数警告
__unused static void privoxy_log_callback(const char *message) {
    if (!message) {
        return;
    }
    
    NSString *logMessage = [NSString stringWithUTF8String:message];
    
    if (sharedInstance && sharedInstance.delegate && 
        [sharedInstance.delegate respondsToSelector:@selector(privoxyLogMessage:)]) {
        [sharedInstance.delegate privoxyLogMessage:logMessage];
    }
}